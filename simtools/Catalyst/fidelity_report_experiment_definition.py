import argparse
import json
from collections import defaultdict
import numpy as np
import os
import pandas as pd
import scipy.stats as stats
import matplotlib.pyplot as plt

from simtools.Catalyst.fidelity_html_report import FidelityHTMLReport

class FidelityReportExperimentDefinition(defaultdict):
    """Constructs experiement definition dictionary based on the fidelity report .json config file or based on the exp_def.json file generated by a previouse report run."""
    def __init__(self, xd_json, args):
        # There are two case:
        if 'default' not in xd_json and 'exp_id' in xd_json:
            # 1. using experiment .json of the previouse report generation (used more for development or troubleshooting)
            self.set_keys(xd_json)
        else:
            # 2. using input arguments and experiment definition from the specified fidelity report .json file (can be detected by the presence of the 'default' key )
            self.init_experiment_definition(xd_json, args.mode, args.sweep, args.report)

        # Override experiment definition with keys specified from command line
        for k in FidelityHTMLReport.all_keys():
            if hasattr(args, k) and (getattr(args, k) is not None or k not in self):
                self[k] = getattr(args, k)

        # construct a name for this experiment definition, to be added to the experiment name
        # for example, "SIR_Seattle_fixed_sir-2r-60d-f150-t2000_NEW-BUILD_2e936139-d1a3-e711-940a-0050569e0ef3"
        # the name has several components indicating:
        #     case name ("SIR_Seattle")
        #     type sweep ("fixed_sir")
        #     number of runs ("2r")
        #     duration ("60d" or "full")
        #     steps included in the report ("f150" - from step, "t2000" - to step)
        #     build label ("NEW-BUILD")
        #     experiment id

        # first take the "sweep" type name (for example, in "pop_sampling.json" that is "fixed" or "fixed_sir")
        sweep_type_name = self['sweep'] if 'sweep' in self else ''
        if sweep_type_name == '' and 'def_name' in self and '_' in self['def_name']:
            sweep_type_name = self['def_name'].split('_')[0]

        # determine the duration label
        duration_label = '{}{}'.format(self['duration'], 'd') if self['duration'] is not None else 'full'
        self['def_name'] = '{}-{}r-{}'.format(sweep_type_name, self['nruns'], duration_label)

        # TODO: reconsider if use of spatial channels if needed and potentially remoe it from the report
        # load inset-spatial channel map
        channel_file = os.path.join(os.path.dirname(__file__), 'channels.csv')
        channel_map = pd.read_csv(channel_file)
        channel_map.reset_index()
        channel_map = channel_map[['Inset_Channel', 'Spatial_Channel']]
        channel_map = channel_map[(~channel_map['Inset_Channel'].isnull() & ~channel_map['Spatial_Channel'].isnull())]
        # initiate which spatial channels will be used

        self.init_spatial_channel_names(channel_map)

    def init_experiment_definition(self, xd_json, mode = None, sweep = None, report = None):
        # cmd or default arguments
        run_mode_name = mode or xd_json['default']['mode']
        sweep_type_name = sweep or xd_json['default']['sweep']
        report_channel_list = report or xd_json['default']['report']

        self['mode'] = run_mode_name
        self['sweep'] = sweep_type_name
        self['report'] = report_channel_list

        # init optional keys
        self['spatial'] = False
        # test sample keys postfix
        xi_name = '_max_items'
        for k in self.keys():
            if k.endswith(xi_name):
                self[k] = None

        # load keys for each section

        self.set_keys(xd_json['modes'][run_mode_name])
        self.set_keys(xd_json['sweeps'][sweep_type_name])
        self.set_keys(xd_json['reports'][report_channel_list])

        # validate if required keys are present
        missing_keys = []
        for rk in FidelityHTMLReport.required_keys:
            if rk not in self:
                missing_keys.append(rk)


        if len(missing_keys) > 0:
            raise 'Experiement definition is missing required keys: {}'.format(','.join(missing_keys))

        # reduce lists based on _max_items, used in test modes
        for k in list(self.keys()):
            if k.endswith(xi_name):
                n = self[k]
                if n is not None:
                    # get the original key name by removing postfix
                    tk = k[: ( len(k) - len(xi_name) )]
                    # take only a sample if values for testing purposes
                    self[tk] = self[tk][:n]
                del self[k]

    def init_spatial_channel_names(self, channel_map):
        """Determine the list of spatial channel names."""
        # detirmine spatial channel names if 'spatial' flag is true
        # take the list from exp. def. if present, otherwise read spatial channel names from channel_map
        spatial_channel_names = []
        if 'spatial' in self and self['spatial'] is True:
            spatial_channel_names = None
            if 'spatial_channel_names' in self:
                spatial_channel_names = self['spatial_channel_names']

            if spatial_channel_names is None:
                spatial_channel_names = list(channel_map[channel_map['Inset_Channel'].isin(self['inset_channel_names'])]['Spatial_Channel'])

        self['spatial_channel_names'] = spatial_channel_names

    def set_keys(self, dct):
        for k, v in dct.items():
            self[k] = v

    def get_report_instance_args(self):
        # collect required arguments to instantiate experiemtn report
        keys = FidelityHTMLReport.all_keys()
        keys.append('def_name')
        xd = {k: self[k] if k in self else None for k in keys}

        return xd
